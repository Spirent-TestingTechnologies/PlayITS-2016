#include <SoftwareSerial.h>
#include <Wire.h>
//#include "Adafruit_TCS34725.h"
//#include <NewPing.h>
//#include <Time.h>
//#include <IRremote.h>


#define MAX_PARAM 5

#define XSERIAL Serial // mySerial // Serial // to switch between Bluetooth and USB XSERIAL connection for communication

#define CV01   10
#define PE01   20
#define LED01  30
#define REL01  40
#define MM01   50
#define LS01   70

#define SETUP 1
#define SET 1
#define START 2
#define STOP 3
#define READ 4
#define R1 101 //Result

#define DEBUG 1

#ifdef DEBUG
#define DEBUG_PRINT(x) XSERIAL.print (x)
#define DEBUG_PRINTLN(x) XSERIAL.println (x)
#else
#define DEBUG_PRINT(x)
#define DEBUG_PRINTLN(x)
#endif

unsigned long readTimer; // holds the next read time;
unsigned int readSpeed = 500; // How frequently are we going to read the serial line

//#define CVF_PRESENT 1

#define cvf_ledpin 4

//#define PE_PRESENT 1
#define TRIGGER_PIN 12
#define ECHO_PIN 11
#define MAX_DISTANCE 100


//#define MOTOR_PRESENT 1
#define enablePin 5
#define in1Pin 6
#define in2Pin 7

//#define LEDS_PRESENT 1
//D8+A3 LED bicolor
#define LED1PIN1  8 // HIGH = red
#define LED1PIN2  A3 // HIGH = green
#define LED2PIN   10 // blue

//#define RELAYS_PRESENT 1
#define RELAY1PIN  A1
#define RELAY2PIN  A2

// #define BT_PRESENT 1
#define BT_RX 2
#define BT_TX 3

//#define LS_PRESENT 1
#define LS1PIN A1

//#ifdef BT_PRESENT
SoftwareSerial mySerial(BT_RX, BT_TX); // RX, TX
//#endif

//#define IR_PRESENT 1
#ifdef IR_PRESENT

// IR LED DATA on D9 (PWM)

IRsend irsend;
#endif

// 32 bit NEC IR remote control
#define IR_ON 0xF7C03F
#define IR_OFF 0xF740BF
#define IR_RED 0xF720DF
#define IR_GREEN 0xF7A05F
#define IR_BLUE 0xF7609F
#define IR_WHITE 0xF7E01F
#define IR_FADE 0xF7C837
#define IR_SMOOTH 0xF7E817
#define IR_STROBE 0xF7D02F
#define IR_FLASH 0xF7D02F

void setup() {
  XSERIAL.begin(9600, SERIAL_8N1); // Open serial monitor at 9600 baud
  while (!XSERIAL) {
    ; // wait for serial port to connect. Needed for native USB port only
  }

#ifdef CVF_PRESENT
  if (tcs.begin()) {
    DEBUG_PRINTLN("#Found CVF sensor");
  } else {
    DEBUG_PRINTLN("#No TCS34725 found ... check your connections");
    while (1); // halt!
  }
  // use these three pins to drive an LED
  pinMode(cvf_ledpin, OUTPUT);
  digitalWrite(cvf_ledpin, HIGH);
#else
  DEBUG_PRINTLN("#Found simulated CVF sensor");
#endif

  // LED Config
  pinMode(LED1PIN1, OUTPUT);
  pinMode(LED1PIN2, OUTPUT);
  pinMode(LED2PIN, OUTPUT);

  // Motor Config
  pinMode(enablePin, OUTPUT);
  pinMode(in1Pin, OUTPUT);
  pinMode(in2Pin, OUTPUT);

  // Relay Config
  pinMode(RELAY1PIN, OUTPUT);
  pinMode(RELAY2PIN, OUTPUT);


  // ECHO PING Config in Constructor of SONAR
  // BT / Softserial Config in Constructor of SoftSerial

  establishContact();  // send a byte to establish contact until receiver responds

  DEBUG_PRINTLN("#Entered loop");
}

void loop() {
  int id, functionType, command;
  if (millis() >= readTimer) {
    readTimer += readSpeed;      // Set the next ping time.
    if (XSERIAL.available() > 0) {
      // Read in loop all data for one line
      id = XSERIAL.parseInt();
      functionType = XSERIAL.parseInt();
      command = XSERIAL.parseInt();

      switch (functionType) {
        case CV01:
        //  ColorViewFunction(id, command);
          break;
        case PE01:
         // PingEchoFunction(id, command);
          break;
        case LED01:
         // LEDFunction(id, command);
          break;
        case REL01:
         // RelayFunction(id, command);
          break;
        case MM01:
         // MotorFunction(id, command);
          break;
        case LS01:
          LightSensorFunction(id, command);
          break;
      }
      processCleanUp();
    }
  }
}
 

// -------- LightSensor ------------
void LightSensorFunction( int id, int command){
  //TODO Debug output
  DEBUG_PRINT("\n#In the LightSensorFunction with function : '");
  DEBUG_PRINTLN(command);
  
  DEBUG_PRINT("' and with ID: ");
  DEBUG_PRINTLN(id);

  switch(command){
    case READ:{
      LightFunctionRead(id);
      break;
    }
    case START:{
      int valueDiff = XSERIAL.parseInt();
      int valueNow = analogRead(LS1PIN);
      LightFunctionStart(id,valueDiff,valueNow);
      break;
    }
    case STOP:{
      LightFunctionStop(id,0.0);
      break;
    }
    default:
      break;
  }
  // ID, LS01, R1, <brightness:int>, <timestamp:long>
}
void LightFunctionPrint(int id,int value,unsigned long time){
    DEBUG_PRINTLN("# In the sub-function LightFunctionPrint of LightSensorFunction");
    DEBUG_PRINT("# with id");
    DEBUG_PRINTLN(id);
    
    XSERIAL.print(id); XSERIAL.print(", ");
    XSERIAL.print(LS01);  XSERIAL.print(", ");
    XSERIAL.print(R1);  XSERIAL.print(", ");
    XSERIAL.print(value);  XSERIAL.print(", ");
    XSERIAL.println(time);
    XSERIAL.flush();
  }
  //print funktion für die Frequenz
  void LightFunctionPrint2(int id,float value,unsigned long time){
    DEBUG_PRINTLN("# In the sub-function LightFunctionPrint of LightSensorFunction");
    DEBUG_PRINT("# with id");
    DEBUG_PRINTLN(id);
    
    XSERIAL.print(id); XSERIAL.print(", ");
    XSERIAL.print(LS01);  XSERIAL.print(", ");
    XSERIAL.print(R1);  XSERIAL.print(", ");
    XSERIAL.print(value);  XSERIAL.print(", ");
    XSERIAL.println(time);
    XSERIAL.flush();
  }
  void LightFunctionRead(int id){
    //gibt dauerhaft die aktuelle Helligkeit und Zeit zurück
    DEBUG_PRINTLN("# In the sub-function LightFunctionRead of LightSensorFunction");
    DEBUG_PRINT("# with id");
    DEBUG_PRINTLN(id);
    
    while(Serial.available()<=0){
      LightFunctionPrint(id,analogRead(LS1PIN),millis());
    }
  }
  void LightFunctionStart(int id,int valueDiff,int valueDown){
    //gibt sobald sich die Helligkeit um valueMax geändert hat die Helligkeit und Zeit
    //zurück
    DEBUG_PRINTLN("# In the sub-function LightFunctionStart of LightSensorFunction");
    DEBUG_PRINT("# with id");
    DEBUG_PRINTLN(id);
    int counter = 0;
    unsigned long startTime;
    boolean AnAus;
    int valueNow;
    
    while(Serial.available()<=0){  
      //auf wechsel warten, je nach dem ob wir bei hell oder dunkel angefangen haben
      valueNow = analogRead(LS1PIN); 
      if(valueNow>=valueDown+valueDiff){
        startTime = millis();
        counter++;
        AnAus = true;
        LightFunctionFrequenz(id,valueDown,0.0,valueDiff,AnAus,startTime,counter,millis());
        return;
      }
      //falls auf die wartende helligkeit ins negative gehen würde setze sie auf 0
      int valueX = valueDown-valueDiff;
      if(valueX < 0){
        valueX = 0;
      }
       if(valueNow <= valueX){
        startTime = millis();
        counter++;
        AnAus = false; 
        LightFunctionFrequenz(id,valueNow,0.0,valueDiff,AnAus,startTime,counter,millis());
        return;
      }
    }
    ////////wenn hier abfrage kommt ist die frequenz 0.0 da es noch keinen wechsel gab
    int functionType, command;
    if (millis() >= readTimer) {
      readTimer += readSpeed;      // Set the next ping time.
    if (XSERIAL.available() > 0) {
      // Read in loop all data for one line
      id = XSERIAL.parseInt();
      functionType = XSERIAL.parseInt();
      command = XSERIAL.parseInt();
      switch (functionType) {
        case CV01:
        //  ColorViewFunction(id, command);
          break;
        case PE01:
         // PingEchoFunction(id, command);
          break;
        case LED01:
         // LEDFunction(id, command);
          break;
        case REL01:
         // RelayFunction(id, command);
          break;
        case MM01:
         // MotorFunction(id, command);
          break;
        case LS01:
          switch(command){
            case READ:{       
              if(XSERIAL.parseInt()==1){
                //gib die aktuelle frequenz zurück und mache weiter
                LightFunctionPrint2(id,0.0,millis());
                LightFunctionStart(id,valueDiff,valueDown);
              }
              else{
                //starte neu, rufe normale Read auf
                 LightFunctionRead(id);
              }  
               break;}
            case START:{
               // starte neu 
                int valueMax = XSERIAL.parseInt();
                int value = analogRead(LS1PIN);
                LightFunctionStart(id,valueMax,value);  
                break;}
            case STOP:{
                LightFunctionStop(id,0.0);
               break;}
          }
          break;
      }
      processCleanUp();
    } 
  }
  }
 void LightFunctionFrequenz(int id,int valueDown,float frequenz,int valueDiff,boolean highDown,unsigned long startZeit,int counter,unsigned long endZeit){
    int valueNow;
    float frequenzNow;
  while(Serial.available()<=0){
    valueNow = analogRead(LS1PIN);
    if(valueNow>=valueDown+valueDiff && highDown == false){
      highDown = true;
      endZeit = millis();
      counter++;
    }
    int valueX = valueDown-valueDiff;
    if(valueX < 0){
        valueX = 0;
    }
    if(valueNow <=valueX && highDown == true){
      endZeit = millis();
      highDown = false;
      counter++;
    }
  }

  //////////Berechne Frequenz//////////////////
  frequenzNow = counter*1000/(endZeit-startZeit);
  if(frequenz != 0){
     frequenz = (frequenz+frequenzNow)/2;
  }
  else{
    frequenz = frequenzNow;
  }
  ///////////ReadInput//////////////////
  int functionType, command;
     if (millis() >= readTimer) {
    readTimer += readSpeed;      // Set the next ping time.
    if (XSERIAL.available() > 0) {
      // Read in loop all data for one line
      id = XSERIAL.parseInt();
      functionType = XSERIAL.parseInt();
      command = XSERIAL.parseInt();

      switch (functionType) {
        case CV01:
        //  ColorViewFunction(id, command);
          break;
        case PE01:
         // PingEchoFunction(id, command);
          break;
        case LED01:
         // LEDFunction(id, command);
          break;
        case REL01:
         // RelayFunction(id, command);
          break;
        case MM01:
         // MotorFunction(id, command);
          break;
        case LS01:
          switch(command){
            case READ:{       
              if(XSERIAL.parseInt()==1){
                //gib die aktuelle frequenz zurück und mache weiter
                LightFunctionPrint2(id,frequenz,millis());
                LightFunctionFrequenz(id,valueDown,frequenz,valueDiff,highDown,millis(),counter,endZeit);
              }
              else{
                //starte neu, rufe normale Read auf
                 LightFunctionRead(id);
              }  
               break;}
            case START:{
               // starte neu 
                int valueMax = XSERIAL.parseInt();
                int value = analogRead(LS1PIN);
                LightFunctionStart(id,valueMax,value);  
                break;}
            case STOP:{
                LightFunctionStop(id,frequenz);
               break;}
          }
          break;
      }
      processCleanUp();
    } 
  }
  
 }
 void LightFunctionStop(int id,float frequenz){
    //gibt die Helligkeit und Zeit zurück
    DEBUG_PRINTLN("# In the sub-function LightFunctionRead of LightSensorFunction");
    DEBUG_PRINT("# with id");
    DEBUG_PRINTLN(id);
    LightFunctionPrint2(id,frequenz,millis());
  }

  
// ----------------- GENERAL CONFIG ------------
void establishContact() {
  while (XSERIAL.available() <= 0) {
    XSERIAL.print("0,0,0,");   // send an initial string
    XSERIAL.println(millis());
    delay(1000);
  }
}

void processCleanUp () {
  // If we are here rest ist rubbish
  int i;
  DEBUG_PRINTLN("#CleanUp");
  while (XSERIAL.available() > 0) {
    i = XSERIAL.read();
  }
}
