//** @desc Testing Door Status
module CodecTests language "TTCN-3:2010 Advanced Parameterization" {

	import from PhyIOAUX all;
	import from Components all;
	
	type record of boolean RecordList;
	
	testcase EncodingTestcase() runs on me system me {
		var RecordList verdicts;
		var integer idx := 0;
		
		var RFID SAMPLE_RFID := {255, 0, 2, 156}
		
		// TODO there has got to be a better way to make these calls, like a list or something...
		
		// LED
		verdicts[idx] := checkEncode<SwitchLED>(SwitchLED: true,		"30, 1, 1");				idx := idx + 1;
		verdicts[idx] := checkEncode<SwitchLED>(SwitchLED: false,		"30, 1, 0");				idx := idx + 1;
		verdicts[idx] := checkEncode<BlinkLEDStart>(BlinkLEDStart: 0.4,	"30, 5, 0.4");				idx := idx + 1;
		verdicts[idx] := checkEncode<BlinkLEDStop>(BlinkLEDStop: {},	"30, 3");					idx := idx + 1;
		
		// RFID
		verdicts[idx] := checkEncode<ReadRFIDStart>(ReadRFIDStart: {},	"80, 2");					idx := idx + 1;
		verdicts[idx] := checkEncode<ReadRFIDStop>(ReadRFIDStop: {},	"80, 3");					idx := idx + 1;
		verdicts[idx] := checkEncode<RFID>(RFID: SAMPLE_RFID,			"80, 1, 255, 0, 2, 156");	idx := idx + 1;
		verdicts[idx] := checkDecode<RFID>(RFID: SAMPLE_RFID,			"80, 101, 255, 0, 2, 156");	idx := idx + 1;
		
		// Door
		verdicts[idx] := checkEncode<ReadDoorStart>(ReadDoorStart: {},	"60, 2");					idx := idx + 1;
		verdicts[idx] := checkEncode<ReadDoorStop>(ReadDoorStop: {},	"60, 3");					idx := idx + 1;
		verdicts[idx] := checkEncode<DoorState>(DoorState: true,		"60, 101, 1");				idx := idx + 1;
		
		// Distance Sensor
		verdicts[idx] := checkEncode<DistanceSensorSetup>(DistanceSensorSetup: 0.1,	"21, 1, 0.1");	idx := idx + 1;
		verdicts[idx] := checkEncode<ReadDistanceStart>(ReadDistanceStart: {},		"21, 2");		idx := idx + 1;
		verdicts[idx] := checkEncode<ReadDistanceStop>(ReadDistanceStop: {},		"21, 3");		idx := idx + 1;
		verdicts[idx] := checkEncode<DistanceSensorState>(DistanceSensorState: {3, 1002}, "21, 101, 3, 1002"); idx := idx + 1;
		
		// Light Sensor
		verdicts[idx] := checkEncode<ReadFrequencyStart>(ReadFrequencyStart: 8,		"70, 2, 8");	idx := idx + 1;
		verdicts[idx] := checkEncode<ReadFrequencyStop>(ReadFrequencyStop: {},		"70, 3");		idx := idx + 1;
		// ReadLightSwitchStart/Stop is not used anymore -> no tests
		verdicts[idx] := checkEncode<ReadLightSensorState>(READ_BRIGHTNESS,			"70, 4, 0");	idx := idx + 1;
		verdicts[idx] := checkEncode<ReadLightSensorState>(READ_FREQUENCY,			"70, 4, 1");	idx := idx + 1;
		verdicts[idx] := checkDecode<State>(State: {37, 1002},						"70, 101, 37, 1002"); idx := idx + 1;
		verdicts[idx] := checkDecode<Frequency>(Frequency: 3.25,					"70, 101, 3.25"); idx := idx + 1;
		
		for (var integer i := 0; i < lengthof(verdicts); i :=i  + 1) {
			if(verdicts[i] == false) {
				setverdict(fail);
				break;
			}
		}

		if(getverdict == none) {
			setverdict(pass);
		}
	}
	
	function checkEncode<T>(T object, charstring encoded) return boolean {
		var bitstring b := encvalue(object);
	
		var charstring str := oct2char(bit2oct(b));
		
		return str == encoded;
	}
	
	function checkDecode<T>(T object, charstring encoded) return boolean {
		var T expected := object;
		
		var bitstring bt := oct2bit(char2oct(encoded));
		var integer r := decvalue(bt, object);
		
		return r == 0 and expected == object;
	}
	
	/**
	 * @desc Executes a codec test, decode, encode and the decode the encoded value and match against the first decoded value
	 * @return the value decoded the first time
	 */
	function codecTestTwice<T>(
		in bitstring p_encodedMessage,
		out verdicttype p_verdict,
		in boolean p_enableLog := true) return T {
		var T expect_decoded_logfile;

		//First decoding
		var integer dec_result := decvalue(p_encodedMessage, expect_decoded_logfile);
		if (p_enableLog) {
			log("decoding result is: ", int2str(dec_result));
		}
		if(dec_result != 0){
			p_verdict := fail;//verdictFail("Couldn't decode the message");
		}else{
			if (p_enableLog) {
				log("decoded value: ", expect_decoded_logfile);
			}
			if (isvalue(expect_decoded_logfile) == false) {
				p_verdict := fail;//verdictFail("Couldn't decode the message");
			}else{

				//First encoding
				var bitstring encoded_bs := encvalue(expect_decoded_logfile);
				//oct2char(bit2oct(..)):
				var T result_decoded_logfile;

				//Second decoding
				dec_result := decvalue(encoded_bs, result_decoded_logfile);

				if (match(result_decoded_logfile, expect_decoded_logfile)) {
					p_verdict := pass;//verdictPass("decoded value matches");
				} else {
					p_verdict := fail;//verdictFail("decoded value mismatch");
				}
			}
		}
		if (p_enableLog) {
			log("CodecTestTwice test verdict: ", p_verdict);
		}
		return expect_decoded_logfile;
	}
	
	/* @desc Assertion function. If condition is false, set the given verdict with the error message.
	@param p_condition the assertion boolean condition @param p_errorMessage the assertion message
	@param p_verdict the assertion verdict @param p_stopOnFail if the verdict is fail, stop all components
	@verdict p_verdict if condition is false */
	function assert(in boolean p_condition, in charstring p_errorMessage, in verdicttype p_verdict := fail, in boolean p_stopOnFail := true) {
		if (not p_condition) {
			setverdict(p_verdict, p_errorMessage);
			if (p_stopOnFail and p_verdict == fail) {
				testcase.stop(p_errorMessage);
			}
		}
	}
}